{
	"info": {
		"_postman_id": "f1f1588f-e598-4d50-9a20-2904231b4b66",
		"name": "Healthcheck",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Frontpage",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Returns status 200 OK\", function() {",
							"    pm.response.to.have.status(200)",
							"    pm.response.to.be.ok",
							"})",
							"",
							"pm.test(\"Response time below 150 ms\", function() {",
							"    pm.expect(pm.response.responseTime).to.be.below(150)",
							"})",
							"",
							"pm.test(\"Is HTML with text\", function() {",
							"    pm.expect(pm.response.headers.get('Content-Type')).to.include('text/html');",
							"    pm.expect(pm.response.text()).to.include('This page intentionally left blank');",
							"})"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{host}}",
					"host": [
						"{{host}}"
					]
				}
			},
			"response": []
		},
		{
			"name": "security.txt",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Returns status 200 OK\", function() {",
							"    pm.response.to.have.status(200)",
							"    pm.response.to.be.ok",
							"    /**",
							"     * The expected file format of the security.txt file is plain text (MIME",
							"     * type \"text/plain\") as defined in section 4.1.3 of [RFC2046] and is",
							"     * encoded using UTF-8 [RFC3629] in Net-Unicode form [RFC5198].",
							"     */",
							"    const contentType = pm.response.headers.get('Content-Type').toLowerCase()",
							"    pm.expect(contentType).to.eql('text/plain; charset=utf8')",
							"})",
							"",
							"const content = pm.response.text()",
							"const contentLines = content.split('\\n')",
							"const contact = getFields('Contact')",
							"const policy = getFields('Policy')",
							"const encryption = getFields('Encryption')",
							"const preferredLanguages = getFields('Preferred-Languages')",
							"const canonical = getFields('Canonical')",
							"const expires = getFields('Expires')",
							"",
							"pm.test(\"Field: Canonical\", function() {",
							"    /**",
							"     * This field indicates the canonical URIs where the security.txt file",
							"     * is located, which is usually something like",
							"     * \"https://example.com/.well-known/security.txt\".  If this field",
							"     * indicates a web URL, then it MUST begin with \"https://\" (as per",
							"     * section 2.7.2 of [RFC7230]).  The purpose of this field is to allow a",
							"     * digital signature to be applied to the locations of the",
							"     * \"security.txt\" file.",
							"     */",
							"    const requestUrl = pm.request.url.toString()",
							"    ",
							"    pm.expect(canonical.length).to.be.greaterThan(0)",
							"    pm.expect(canonical).to.include(requestUrl)",
							"})",
							"",
							"pm.test(\"Field: Contact\", function() {",
							"    /**",
							"     *    This field indicates an address that researchers should use for",
							"     *    reporting security vulnerabilities such as an email address, a phone",
							"     *    number and/or a web page with contact information.  The \"Contact\"",
							"     *    field MUST always be present in a security.txt file.  If this field",
							"     *    indicates a web URL, then it MUST begin with \"https://\" (as per",
							"     *    section 2.7.2 of [RFC7230]).  Security email addresses should use the",
							"     *    conventions defined in section 4 of [RFC2142].",
							"     * ",
							"     *    The value MUST follow the URI syntax described in [RFC3986].  This",
							"     *    means that \"mailto\" and \"tel\" URI schemes must be used when",
							"     *    specifying email addresses and telephone numbers, as defined in",
							"     *    [RFC6068] and [RFC3966].  When the value of this field is an email",
							"     *    address, it is RECOMMENDED that encryption be used (as per",
							"     *    Section 3.5.4).",
							"     */",
							"    pm.expect(contact.length).to.be.greaterThan(0)",
							"    const invalidURIs = contact.filter(c => !c.startsWith('mailto:') && !c.startsWith('https://') && !c.startsWith('tel:'))",
							"    pm.expect(invalidURIs.length).to.eql(0)",
							"})",
							"",
							"pm.expect(encryption.length).to.be.eql(1)",
							"pm.expect(encryption[0].startsWith('https://')).to.be.true",
							"pm.sendRequest(encryption[0], (err, res) => {",
							"    pm.test(\"Field: Encryption\", function() {",
							"        /**",
							"         *    This field indicates an encryption key that security researchers",
							"         *    should use for encrypted communication.  Keys MUST NOT appear in this",
							"         *    field - instead the value of this field MUST be a URI pointing to a",
							"         *    location where the key can be retrieved.  If this field indicates a",
							"         *    web URL, then it MUST begin with \"https://\" (as per section 2.7.2 of",
							"         *    [RFC7230]).",
							"         * ",
							"         *    When it comes to verifying the authenticity of the key, it is always",
							"         *    the security researcher's responsibility to make sure the key being",
							"         *    specified is indeed one they trust.  Researchers must not assume that",
							"         *    this key is used to generate the digital signature referenced in",
							"         *    Section 3.4.",
							"         */",
							"        pm.expect(err).to.be.null",
							"        pm.expect(res).to.be.not.null",
							"        pm.expect(res.code).to.be.eq(200)",
							"        ",
							"        const content = res.text()",
							"        pm.expect(content).to.be.not.null",
							"        pm.expect(content.startsWith('-----BEGIN PGP PUBLIC KEY BLOCK-----')).to.be.true",
							"    });",
							"})",
							"",
							"pm.test(\"Field: Expires\", function() {",
							"    /**",
							"     * This field indicates the date and time after which the data contained",
							"     * in the \"security.txt\" file is considered stale and should not be used",
							"     * (as per Section 6.3).  The value of this field follows the format",
							"     * defined in section 3.3 of [RFC5322].  It is RECOMMENDED that the",
							"     * value of this field be less than a year into the future to avoid",
							"     * staleness.",
							"     * ",
							"     * This field MUST always be present and MUST NOT appear more than once.",
							"     */",
							"    pm.expect(expires.length).to.be.eql(1)",
							"    const exp = new Date(expires[0])",
							"    const now = new Date()",
							"",
							"    pm.expect(expires).to.be.not.eql(null)",
							"    // Less than a year",
							"    pm.expect(addDays(exp, -365)).to.lessThan(now)",
							"    // Longer than a month",
							"    pm.expect(addDays(exp, -30)).to.greaterThan(now)",
							"})",
							"",
							"pm.expect(policy.length).to.be.eql(1)",
							"pm.expect(policy[0].startsWith('https://')).to.be.true",
							"pm.sendRequest(policy[0], (err, res) => {",
							"    pm.test(\"Field: Policy\", function() {",
							"        /**",
							"         * This field indicates a link to where the vulnerability disclosure",
							"         * policy is located.  This can help security researchers understand the",
							"         * organization's vulnerability reporting practices.  If this field",
							"         * indicates a web URL, then it MUST begin with \"https://\" (as per",
							"         * section 2.7.2 of [RFC7230]).",
							"         */",
							"        pm.expect(err).to.be.null",
							"        pm.expect(res).to.be.not.null",
							"        pm.expect(res.code).to.be.eq(200)",
							"    });",
							"})",
							"",
							"pm.test(\"Field: Preferred-Languages\", function() {",
							"    /**",
							"     * This field can be used to indicate a set of natural languages that",
							"     * are preferred when submitting security reports.  This set MAY list",
							"     * multiple values, separated by commas.  If this field is included then",
							"     * at least one value MUST be listed.  The values within this set are",
							"     * language tags (as defined in [RFC5646]).  If this field is absent,",
							"     * security researchers may assume that English is the language to be",
							"     * used (as per section 4.5 of [RFC2277]).",
							"     * ",
							"     * The order in which they appear MUST NOT be interpreted as an",
							"     * indication of priority - rather these MUST be interpreted as all",
							"     * being of equal priority.",
							"     * ",
							"     * This field MUST NOT appear more than once.",
							"     */",
							"    pm.expect(preferredLanguages).to.be.not.null",
							"    pm.expect(preferredLanguages.length).to.be.eql(1)",
							"    pm.expect(preferredLanguages[0]).to.include('en')",
							"})",
							"",
							"function getFields(fieldName) {",
							"    const fields = contentLines.filter(line => line.startsWith(fieldName))",
							"    if (!fields) {",
							"        return []",
							"    }",
							"    const fieldNameExpression = createFieldNameExpression(fieldName)",
							"    return fields.map(field => trimFieldName(field, fieldNameExpression))",
							"}",
							"",
							"function trimFieldName(field, fieldNameExpression) {",
							"    return field.substring(field.indexOf(fieldNameExpression) + fieldNameExpression.length)",
							"}",
							"",
							"function createFieldNameExpression(fieldName) {",
							"    return fieldName + ': '",
							"}",
							"",
							"function addDays(original, daysToAdd) {",
							"    var date = new Date(original);",
							"    date.setDate(date.getDate() + daysToAdd);",
							"    return date;",
							"}"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{host}}/.well-known/security.txt",
					"host": [
						"{{host}}"
					],
					"path": [
						".well-known",
						"security.txt"
					]
				}
			},
			"response": []
		}
	]
}